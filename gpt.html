<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<title>圣诞树</title>

<!-- ================= Fonts ================= -->
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@600&display=swap" rel="stylesheet">

<style>
html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #000;
    font-family: "Times New Roman", serif;
    color: #fceea7;
}

/* ================= Loader ================= */
#loader {
    position: fixed;
    inset: 0;
    background: #000;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 9999;
    transition: opacity 1.2s ease;
}
#loader.hidden {
    opacity: 0;
    pointer-events: none;
}
.spinner {
    width: 40px;
    height: 40px;
    border: 4px solid rgba(255,255,255,0.1);
    border-top: 4px solid #d4af37;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 16px;
}
@keyframes spin {
    to { transform: rotate(360deg); }
}
#loader span {
    letter-spacing: 3px;
    font-size: 12px;
    color: #d4af37;
}

/* ================= Title ================= */
h1 {
    position: fixed;
    top: 20px;
    width: 100%;
    text-align: center;
    font-family: 'Cinzel', serif;
    font-size: 56px;
    background: linear-gradient(180deg, #ffffff, #d4af37);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    text-shadow: 0 0 25px rgba(212,175,55,0.45);
    pointer-events: none;
}

/* ================= UI ================= */
.upload-wrapper {
    position: fixed;
    top: 100px;
    left: 50%;
    transform: translateX(-50%);
    text-align: center;
    transition: opacity .6s ease;
}
.upload-wrapper button {
    padding: 14px 28px;
    background: rgba(255,255,255,0.08);
    border: 1px solid #d4af37;
    color: #fceea7;
    font-family: 'Cinzel', serif;
    letter-spacing: 2px;
    backdrop-filter: blur(12px);
    cursor: pointer;
}
.upload-wrapper p {
    margin-top: 10px;
    font-size: 12px;
    opacity: .7;
}
.ui-hidden {
    opacity: 0;
    pointer-events: none;
}

/* ================= Webcam ================= */
#cv {
    position: fixed;
    right: 10px;
    bottom: 10px;
    opacity: 0;
}
</style>

<!-- ================= Import Map ================= -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
    "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
  }
}
</script>
</head>

<body>

<!-- Loader -->
<div id="loader">
    <div class="spinner"></div>
    <span>LOADING HOLIDAY MAGIC</span>
</div>

<h1>Merry Christmas</h1>

<div class="upload-wrapper" id="ui">
    <button id="uploadBtn">ADD MEMORIES</button>
    <p>Press 'H' to Hide Controls</p>
    <input type="file" id="file" accept="image/*" hidden />
</div>

<!-- Webcam -->
<div id="cv">
    <video id="video" autoplay playsinline></video>
    <canvas id="canvas" width="160" height="120"></canvas>
</div>

<script type="module">
import * as THREE from 'three';
import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

import {
    FilesetResolver,
    HandLandmarker
} from "@mediapipe/tasks-vision";

/* ================= Global State ================= */
const STATE = {
    mode: 'TREE',
    gesture: null
};

/* ================= Scene ================= */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 0.1, 200);
camera.position.set(0, 2, 50);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.toneMapping = THREE.ReinhardToneMapping;
renderer.toneMappingExposure = 2.2;
document.body.appendChild(renderer.domElement);

/* ================= Environment ================= */
const pmrem = new THREE.PMREMGenerator(renderer);
scene.environment = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;

/* ================= Post ================= */
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
composer.addPass(new UnrealBloomPass(
    new THREE.Vector2(innerWidth, innerHeight),
    0.45, 0.4, 0.7
));

/* ================= Lights ================= */
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
scene.add(new THREE.PointLight(0xffaa55, 2));

const s1 = new THREE.SpotLight(0xd4af37, 1200);
s1.position.set(30, 40, 40);
scene.add(s1);

const s2 = new THREE.SpotLight(0x3366ff, 600);
s2.position.set(-30, 20, -30);
scene.add(s2);

/* ================= Main Group ================= */
const mainGroup = new THREE.Group();
scene.add(mainGroup);

/* ================= Particle Class ================= */
class Particle {
    constructor(mesh, type='GENERIC') {
        this.mesh = mesh;
        this.type = type;
        this.base = new THREE.Vector3();
        this.target = new THREE.Vector3();
        this.velocity = new THREE.Vector3(
            (Math.random()-0.5)*0.01,
            (Math.random()-0.5)*0.01,
            (Math.random()-0.5)*0.01
        );
    }
    update() {
        this.mesh.position.lerp(this.target, 0.06);
        if (STATE.mode === 'SCATTER') {
            this.mesh.rotation.x += this.velocity.x;
            this.mesh.rotation.y += this.velocity.y;
        }
    }
}

/* ================= Particles ================= */
const particles = [];
const maxRadius = 12;

function createParticles() {
    for (let i = 0; i < 1500; i++) {
        const geo = Math.random() > 0.5
            ? new THREE.BoxGeometry(0.6,0.6,0.6)
            : new THREE.SphereGeometry(0.4,16,16);

        const mat = Math.random() > 0.5
            ? new THREE.MeshStandardMaterial({ color: 0xd4af37, metalness: .9, roughness:.2 })
            : new THREE.MeshPhysicalMaterial({ color: 0xaa0000, clearcoat: 1 });

        const mesh = new THREE.Mesh(geo, mat);
        mainGroup.add(mesh);
        particles.push(new Particle(mesh));
    }
}
createParticles();

/* ================= Candy Cane ================= */
function createCandyCane() {
    const pts = [];
    for (let i=0;i<20;i++) {
        const t = i/19;
        pts.push(new THREE.Vector3(
            Math.sin(t*Math.PI)*2,
            t*6,
            0
        ));
    }
    const curve = new THREE.CatmullRomCurve3(pts);
    const geo = new THREE.TubeGeometry(curve, 64, 0.3, 16);

    const c = document.createElement('canvas');
    c.width = c.height = 256;
    const ctx = c.getContext('2d');
    ctx.fillStyle = '#fff';
    ctx.fillRect(0,0,256,256);
    ctx.strokeStyle = '#c00';
    ctx.lineWidth = 30;
    for(let i=-256;i<512;i+=60){
        ctx.beginPath();
        ctx.moveTo(i,0);
        ctx.lineTo(i+256,256);
        ctx.stroke();
    }

    const tex = new THREE.CanvasTexture(c);
    const mat = new THREE.MeshStandardMaterial({ map: tex });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(0,5,0);
    mainGroup.add(mesh);
}
createCandyCane();

/* ================= Photo ================= */
function createDefaultPhoto() {
    const c = document.createElement('canvas');
    c.width = 512; c.height = 512;
    const ctx = c.getContext('2d');
    ctx.fillStyle = '#111';
    ctx.fillRect(0,0,512,512);
    ctx.fillStyle = '#fceea7';
    ctx.font = '48px Cinzel';
    ctx.textAlign = 'center';
    ctx.fillText('JOYEUX NOEL',256,280);

    const tex = new THREE.CanvasTexture(c);
    addPhotoToScene(tex);
}

function addPhotoToScene(texture) {
    texture.colorSpace = THREE.SRGBColorSpace;

    const frame = new THREE.Mesh(
        new THREE.BoxGeometry(6.5,6.5,0.4),
        new THREE.MeshStandardMaterial({ color:0xd4af37, metalness:.8 })
    );
    const photo = new THREE.Mesh(
        new THREE.PlaneGeometry(6,6),
        new THREE.MeshStandardMaterial({ map:texture })
    );
    photo.position.z = 0.26;
    frame.add(photo);
    frame.position.set(
        (Math.random()-0.5)*10,
        Math.random()*8,
        (Math.random()-0.5)*10
    );
    mainGroup.add(frame);
    particles.push(new Particle(frame,'PHOTO'));
}
createDefaultPhoto();

/* ================= Upload ================= */
uploadBtn.onclick = () => file.click();
file.onchange = e => {
    const f = e.target.files[0];
    if(!f) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
        new THREE.TextureLoader().load(ev.target.result, (t) => {
            t.colorSpace = THREE.SRGBColorSpace;
            addPhotoToScene(t);
        });
    }
    reader.readAsDataURL(f);
};

/* ================= Gestures ================= */
async function initCV() {
    const resolver = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
    );
    const hand = await HandLandmarker.createFromOptions(resolver,{
        baseOptions:{ modelAssetPath:
            "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
            delegate:"GPU"
        },
        numHands:1
    });

    const video = document.getElementById('video');
    video.srcObject = await navigator.mediaDevices.getUserMedia({ video:true });

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    function loop() {
        ctx.drawImage(video,0,0,160,120);
        const r = hand.detectForVideo(video, performance.now());
        if (r.landmarks?.length) {
            const lm = r.landmarks[0];
            const d = (a,b)=>Math.hypot(a.x-b.x,a.y-b.y);

            const pinch = d(lm[4],lm[8])<0.05;
            const avg = (d(lm[12],lm[0])+d(lm[16],lm[0])+d(lm[20],lm[0]))/3;

            if(pinch) STATE.mode='FOCUS';
            else if(avg<0.25) STATE.mode='TREE';
            else if(avg>0.4) STATE.mode='SCATTER';

            mainGroup.rotation.y = (lm[9].x-0.5)*1.5;
            mainGroup.rotation.x = (lm[9].y-0.5)*1.2;
        }
        requestAnimationFrame(loop);
    }
    loop();
}
initCV();

/* ================= Animate ================= */
function animate() {
    particles.forEach((p,i)=>{
        if (STATE.mode==='TREE') {
            const t = i/particles.length;
            const r = maxRadius*(1-t);
            const a = t*50*Math.PI;
            p.target.set(
                Math.cos(a)*r,
                t*20,
                Math.sin(a)*r
            );
        }
        if (STATE.mode==='SCATTER') {
            p.target.set(
                (Math.random()-0.5)*20,
                (Math.random()-0.5)*20,
                (Math.random()-0.5)*20
            );
        }
        if (STATE.mode==='FOCUS' && p.type==='PHOTO') {
            p.target.set(0,2,35);
            p.mesh.scale.lerp(new THREE.Vector3(4.5,4.5,4.5),0.1);
        } else {
            p.mesh.scale.lerp(new THREE.Vector3(1,1,1),0.1);
        }
        p.update();
    });

    composer.render();
    requestAnimationFrame(animate);
}
animate();

/* ================= UI ================= */
window.addEventListener('keydown',e=>{
    if(e.key.toLowerCase()==='h'){
        ui.classList.toggle('ui-hidden');
    }
});

window.addEventListener('resize',()=>{
    camera.aspect=innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
    composer.setSize(innerWidth,innerHeight);
});

setTimeout(()=>loader.classList.add('hidden'),1800);
</script>

</body>
</html>
